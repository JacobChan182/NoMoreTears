def get_segments_for_quiz(db, lecture_id):
    """
    Fetches Twelve Labs segments for a specific lecture and formats them 
    into a prompt context that forces one question per segment.
    """
    if db is None:
        print("‚ùå Database not connected")
        return "ERROR: Database not connected."
    
    if not lecture_id:
        print("‚ùå No lecture ID provided")
        return "ERROR: No lecture ID provided."
    
    print(f"üîç Searching for lecture_id: {lecture_id}")
    
    # 1. Search in 'lecturers' collection
    collection = db["lecturers"]
    doc = collection.find_one(
        {"lectures.lectureId": lecture_id},
        {"lectures.$": 1}
    )

    # 2. Fallback to 'courses' collection if not found
    if not doc or "lectures" not in doc or not doc["lectures"]:
        print("‚ÑπÔ∏è Not found in lecturers, falling back to courses")
        courses_col = db["courses"]
        doc = courses_col.find_one(
            {"lectures.lectureId": lecture_id},
            {"lectures.$": 1}
        )

    # 3. Handle 'Not Found' error with debug info
    if not doc or "lectures" not in doc or not doc["lectures"]:
        print(f"‚ùå No lecture found with lectureId: {lecture_id}")
        try:
            # Helper for developers: find a valid ID to test with
            sample = db["courses"].find_one({}, {"lectures.lectureId": 1})
            if sample and "lectures" in sample:
                print(f"üí° Try testing with this ID instead: {sample['lectures'][0].get('lectureId')}")
        except:
            pass
        return f"ERROR: No segments found for lecture {lecture_id} in the database."

    try:
        lecture_data = doc["lectures"][0]
        lecture_title = lecture_data.get('lectureTitle', 'the lecture')
        
        # Extract segments from the Twelve Labs metadata
        raw_meta = lecture_data.get("rawAiMetaData", {})
        segments = raw_meta.get("segments", [])
        
        if not segments:
            print(f"‚ö†Ô∏è Lecture found but 'segments' array is empty for: {lecture_id}")
            return f"ERROR: TwelveLabs data is still processing or empty for lecture {lecture_id}."

        # 4. Build the Structured Context
        # We use a clear header and numbered segments to guide the LLM's attention
        context = (
            f"INSTRUCTIONS FOR AI:\n"
            f"The following are semantic segments generated by Twelve Labs API for the video '{lecture_title}'.\n"
            f"You MUST generate exactly ONE multiple-choice question for EVERY segment listed below.\n"
            f"There are {len(segments)} segments in total, so I expect exactly {len(segments)} questions.\n\n"
            f"--- START OF SEGMENTS ---\n"
        )

        for i, s in enumerate(segments, 1):
            title = s.get('title', f'Segment {i}')
            summary = s.get('summary', 'No summary provided.')
            start = s.get('start_ms', 0) / 1000 # Optional: include timestamps for better context
            end = s.get('end_ms', 0) / 1000

            context += f"SEGMENT #{i} ({start}s - {end}s):\n"
            context += f"TOPIC: {title}\n"
            context += f"CONTENT: {summary}\n\n"
        
        context += "--- END OF SEGMENTS ---\n"
        context += f"Please output the {len(segments)} questions in a JSON format."

        print(f"‚úÖ Successfully generated context for {len(segments)} segments.")
        return context

    except Exception as e:
        print(f"‚ùå Error parsing lecture segments for {lecture_id}: {str(e)}")
        import traceback
        traceback.print_exc()
        return f"ERROR: Failed to read lecture content for {lecture_id}."